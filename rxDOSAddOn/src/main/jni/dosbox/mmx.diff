diff -urN dosbox_orig/include/cpu.h dosbox/include/cpu.h
--- dosbox_orig/include/cpu.h	2011-04-26 10:34:55.000000000 +0200
+++ dosbox/include/cpu.h	2011-12-20 22:54:04.000000000 +0100
@@ -46,6 +46,7 @@
 #define CPU_ARCHTYPE_486OLDSLOW		0x40
 #define CPU_ARCHTYPE_486NEWSLOW		0x45
 #define CPU_ARCHTYPE_PENTIUMSLOW	0x50
+#define CPU_ARCHTYPE_P55CSLOW		0x55
 
 /* CPU Cycle Timing */
 extern Bit32s CPU_Cycles;
diff -urN dosbox_orig/include/mmx.h dosbox/include/mmx.h
--- dosbox_orig/include/mmx.h	1970-01-01 01:00:00.000000000 +0100
+++ dosbox/include/mmx.h	2011-12-27 22:07:36.000000000 +0100
@@ -0,0 +1,89 @@
+/*
+ *  Copyright (C) 2002-2011  The DOSBox Team
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef DOSBOX_MMX_H
+#define DOSBOX_MMX_H
+
+typedef union {
+
+	Bit64u q;
+
+#ifndef WORDS_BIGENDIAN
+	struct {
+		Bit32u d0,d1;
+	} ud;
+
+	struct {
+		Bit32s d0,d1;
+	} sd;
+
+	struct {
+		Bit16u w0,w1,w2,w3;
+	} uw;
+
+	struct {
+		Bit16s w0,w1,w2,w3;
+	} sw;
+
+	struct {
+		Bit8u b0,b1,b2,b3,b4,b5,b6,b7;
+	} ub;
+
+	struct {
+		Bit8s b0,b1,b2,b3,b4,b5,b6,b7;
+	} sb;
+#else
+	struct {
+		Bit32u d1,d0;
+	} ud;
+
+	struct {
+		Bit32s d1,d0;
+	} sd;
+
+	struct {
+		Bit16u w3,w2,w1,w0;
+	} uw;
+
+	struct {
+		Bit16u w3,w2,w1,w0;
+	} sw;
+
+	struct {
+		Bit8u b7,b6,b5,b4,b3,b2,b1,b0;
+	} ub;
+
+	struct {
+		Bit8u b7,b6,b5,b4,b3,b2,b1,b0;
+	} sb;
+#endif
+
+} MMX_reg;
+
+extern MMX_reg reg_mmx[8];
+extern MMX_reg * lookupRMregMM[256];
+
+
+Bit8s  SaturateWordSToByteS(Bit16s value);
+Bit16s SaturateDwordSToWordS(Bit32s value);
+Bit8u  SaturateWordSToByteU(Bit16s value);
+Bit16u SaturateDwordSToWordU(Bit32s value);
+
+void   setFPU(Bit16u tag);
+
+#endif
\ No newline at end of file
diff -urN dosbox_orig/src/cpu/core_normal/prefix_0f_mmx.h dosbox/src/cpu/core_normal/prefix_0f_mmx.h
--- dosbox_orig/src/cpu/core_normal/prefix_0f_mmx.h	1970-01-01 01:00:00.000000000 +0100
+++ dosbox/src/cpu/core_normal/prefix_0f_mmx.h	2011-12-27 21:07:30.000000000 +0100
@@ -0,0 +1,1014 @@
+/*
+ *  Copyright (C) 2002-2011  The DOSBox Team
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+/* State Management */
+	CASE_0F_D(0x77)												/* EMMS */
+	{
+		setFPU(TAG_Empty);
+		break;
+	}
+
+
+/* Data Movement */
+	CASE_0F_D(0x6e)												/* MOVD Pq,Ed */
+	{
+		GetRM;
+		MMX_reg* rmrq=lookupRMregMM[rm];
+		if (rm>=0xc0) {
+			GetEArd;
+			rmrq->ud.d0=*(Bit32u*)eard;
+			rmrq->ud.d1=0;
+		} else {
+			GetEAa;
+			rmrq->ud.d0=LoadMd(eaa);
+			rmrq->ud.d1=0;
+		}
+		break;
+	}
+	CASE_0F_D(0x7e)												/* MOVD Ed,Pq */
+	{
+		GetRM;
+		MMX_reg* rmrq=lookupRMregMM[rm];
+		if (rm>=0xc0) {
+			GetEArd;
+			*(Bit32u*)eard=rmrq->ud.d0;
+		} else {
+			GetEAa;
+			SaveMd(eaa,rmrq->ud.d0);
+		}
+		break;
+	}
+
+	CASE_0F_D(0x6f)												/* MOVQ Pq,Qq */
+	{
+		GetRM;
+		MMX_reg* dest=lookupRMregMM[rm];
+		if (rm>=0xc0) {
+			MMX_reg* src=&reg_mmx[rm&7];
+			dest->q = src->q;
+		} else {
+			GetEAa;
+			dest->q=LoadMq(eaa);
+		}
+		break;
+	}
+	CASE_0F_D(0x7f)												/* MOVQ Qq,Pq */
+	{
+		GetRM;
+		MMX_reg* dest=lookupRMregMM[rm];
+		if (rm>=0xc0) {
+			MMX_reg* src=&reg_mmx[rm&7];
+			dest->q = src->q;
+		} else {
+			GetEAa;
+			SaveMq(eaa,dest->q);
+		}
+		break;
+	}
+
+/* Boolean Logic */
+	CASE_0F_D(0xef)												/* PXOR Pq,Qq */
+	{
+		GetRM;
+		MMX_reg* dest=lookupRMregMM[rm];
+		if (rm>=0xc0) {
+			MMX_reg* src=&reg_mmx[rm&7];
+			dest->q ^= src->q;
+		} else {
+			GetEAa;
+			dest->q ^= LoadMq(eaa);
+		}
+		break;
+	}
+
+	CASE_0F_D(0xeb)												/* POR Pq,Qq */
+	{
+		GetRM;
+		MMX_reg* dest=lookupRMregMM[rm];
+		if (rm>=0xc0) {
+			MMX_reg* src=&reg_mmx[rm&7];
+			dest->q |= src->q;
+		} else {
+			GetEAa;
+			dest->q |= LoadMq(eaa);
+		}
+		break;
+	}
+	CASE_0F_D(0xdb)												/* PAND Pq,Qq */
+	{
+		GetRM;
+		MMX_reg* dest=lookupRMregMM[rm];
+		if (rm>=0xc0) {
+			MMX_reg* src=&reg_mmx[rm&7];
+			dest->q &= src->q;
+		} else {
+			GetEAa;
+			dest->q &= LoadMq(eaa);
+		}
+		break;
+	}
+	CASE_0F_D(0xdf)												/* PANDN Pq,Qq */
+	{
+		GetRM;
+		MMX_reg* dest=lookupRMregMM[rm];
+		if (rm>=0xc0) {
+			MMX_reg* src=&reg_mmx[rm&7];
+			dest->q = ~dest->q & src->q;
+		} else {
+			GetEAa;
+			dest->q = ~dest->q & LoadMq(eaa);
+		}
+		break;
+	}
+
+/* Shift */
+	CASE_0F_D(0xf1)												/* PSLLW Pq,Qq */
+	{
+		GetRM;
+		MMX_reg* dest=lookupRMregMM[rm];
+		MMX_reg src;
+		if (rm>=0xc0) {
+			src.q=reg_mmx[rm&7].q;
+		} else {
+			GetEAa;
+			src.q=LoadMq(eaa);
+		}
+		if (src.q > 15) dest->q = 0;
+		else {
+			dest->uw.w0 <<= src.ub.b0;
+			dest->uw.w1 <<= src.ub.b0;
+			dest->uw.w2 <<= src.ub.b0;
+			dest->uw.w3 <<= src.ub.b0;
+		}
+		break;
+	}
+	CASE_0F_D(0xd1)												/* PSRLW Pq,Qq */
+	{
+		GetRM;
+		MMX_reg* dest=lookupRMregMM[rm];
+		MMX_reg src;
+		if (rm>=0xc0) {
+			src.q=reg_mmx[rm&7].q;
+		} else {
+			GetEAa;
+			src.q=LoadMq(eaa);
+		}
+		if (src.q > 15) dest->q = 0;
+		else {
+			dest->uw.w0 >>= src.ub.b0;
+			dest->uw.w1 >>= src.ub.b0;
+			dest->uw.w2 >>= src.ub.b0;
+			dest->uw.w3 >>= src.ub.b0;
+		}
+		break;
+	}
+	CASE_0F_D(0xe1)												/* PSRAW Pq,Qq */
+	{
+		GetRM;
+		MMX_reg* dest=lookupRMregMM[rm];
+		MMX_reg src;
+		MMX_reg tmp;
+		tmp.q = dest->q;
+		if (rm>=0xc0) {
+			src.q=reg_mmx[rm&7].q;
+		} else {
+			GetEAa;
+			src.q=LoadMq(eaa);
+		}
+		if (!src.q) break;
+		if (src.q > 15) {
+			dest->uw.w0 = (tmp.uw.w0&0x8000)?0xffff:0;
+			dest->uw.w1 = (tmp.uw.w1&0x8000)?0xffff:0;
+			dest->uw.w2 = (tmp.uw.w2&0x8000)?0xffff:0;
+			dest->uw.w3 = (tmp.uw.w3&0x8000)?0xffff:0;
+		} else {
+			dest->uw.w0 >>= src.ub.b0;
+			dest->uw.w1 >>= src.ub.b0;
+			dest->uw.w2 >>= src.ub.b0;
+			dest->uw.w3 >>= src.ub.b0;
+			if (tmp.uw.w0&0x8000) dest->uw.w0 |= (0xffff << (16 - src.ub.b0));
+			if (tmp.uw.w1&0x8000) dest->uw.w1 |= (0xffff << (16 - src.ub.b0));
+			if (tmp.uw.w2&0x8000) dest->uw.w2 |= (0xffff << (16 - src.ub.b0));
+			if (tmp.uw.w3&0x8000) dest->uw.w3 |= (0xffff << (16 - src.ub.b0));
+		}
+		break;
+	}
+	CASE_0F_D(0x71)												/* PSLLW/PSRLW/PSRAW Pq,Ib */
+	{
+		GetRM;
+		Bit8u op=(rm>>3)&7;
+		Bit8u shift=Fetchb();
+		MMX_reg* dest=&reg_mmx[rm&7];
+		switch (op) {
+			case 0x06: 	/*PSLLW*/
+				if (shift > 15) dest->q = 0;
+				else {
+					dest->uw.w0 <<= shift;
+					dest->uw.w1 <<= shift;
+					dest->uw.w2 <<= shift;
+					dest->uw.w3 <<= shift;
+				}
+				break;
+			case 0x02:  /*PSRLW*/
+				if (shift > 15) dest->q = 0;
+				else {
+					dest->uw.w0 >>= shift;
+					dest->uw.w1 >>= shift;
+					dest->uw.w2 >>= shift;
+					dest->uw.w3 >>= shift;
+				}
+				break;
+			case 0x04:  /*PSRAW*/
+				MMX_reg tmp;
+				if (!shift) break;
+				tmp.q = dest->q;
+				if (shift > 15) {
+					dest->uw.w0 = (tmp.uw.w0&0x8000)?0xffff:0;
+					dest->uw.w1 = (tmp.uw.w1&0x8000)?0xffff:0;
+					dest->uw.w2 = (tmp.uw.w2&0x8000)?0xffff:0;
+					dest->uw.w3 = (tmp.uw.w3&0x8000)?0xffff:0;
+				} else {
+					dest->uw.w0 >>= shift;
+					dest->uw.w1 >>= shift;
+					dest->uw.w2 >>= shift;
+					dest->uw.w3 >>= shift;
+					if (tmp.uw.w0&0x8000) dest->uw.w0 |= (0xffff << (16 - shift));
+					if (tmp.uw.w1&0x8000) dest->uw.w1 |= (0xffff << (16 - shift));
+					if (tmp.uw.w2&0x8000) dest->uw.w2 |= (0xffff << (16 - shift));
+					if (tmp.uw.w3&0x8000) dest->uw.w3 |= (0xffff << (16 - shift));
+				}
+				break;
+		}
+		break;
+	}
+	CASE_0F_D(0xf2)												/* PSLLD Pq,Qq */
+	{
+		GetRM;
+		MMX_reg* dest=lookupRMregMM[rm];
+		MMX_reg src;
+		if (rm>=0xc0) {
+			src.q=reg_mmx[rm&7].q;
+		} else {
+			GetEAa;
+			src.q=LoadMq(eaa);
+		}
+		if (src.q > 31) dest->q = 0;
+		else {
+			dest->ud.d0 <<= src.ub.b0;
+			dest->ud.d1 <<= src.ub.b0;
+		}
+		break;
+	}
+	CASE_0F_D(0xd2)												/* PSRLD Pq,Qq */
+	{
+		GetRM;
+		MMX_reg* dest=lookupRMregMM[rm];
+		MMX_reg src;
+		if (rm>=0xc0) {
+			src.q=reg_mmx[rm&7].q;
+		} else {
+			GetEAa;
+			src.q=LoadMq(eaa);
+		}
+		if (src.q > 31) dest->q = 0;
+		else {
+			dest->ud.d0 >>= src.ub.b0;
+			dest->ud.d1 >>= src.ub.b0;
+		}
+		break;
+	}
+	CASE_0F_D(0xe2)												/* PSRAD Pq,Qq */
+	{
+		GetRM;
+		MMX_reg* dest=lookupRMregMM[rm];
+		MMX_reg src;
+		MMX_reg tmp;
+		tmp.q = dest->q;
+		if (rm>=0xc0) {
+			src.q=reg_mmx[rm&7].q;
+		} else {
+			GetEAa;
+			src.q=LoadMq(eaa);
+		}
+		if (!src.q) break;
+		if (src.q > 31) {
+			dest->ud.d0 = (tmp.ud.d0&0x80000000)?0xffffffff:0;
+			dest->ud.d1 = (tmp.ud.d1&0x80000000)?0xffffffff:0;
+		} else {
+			dest->ud.d0 >>= src.ub.b0;
+			dest->ud.d1 >>= src.ub.b0;
+			if (tmp.ud.d0&0x80000000) dest->ud.d0 |= (0xffffffff << (32 - src.ub.b0));
+			if (tmp.ud.d1&0x80000000) dest->ud.d1 |= (0xffffffff << (32 - src.ub.b0));
+		}
+		break;
+	}
+	CASE_0F_D(0x72)												/* PSLLD/PSRLD/PSRAD Pq,Ib */
+	{
+		GetRM;
+		Bit8u op=(rm>>3)&7;
+		Bit8u shift=Fetchb();
+		MMX_reg* dest=&reg_mmx[rm&7];
+		switch (op) {
+			case 0x06: 	/*PSLLD*/
+				if (shift > 31) dest->q = 0;
+				else {
+					dest->ud.d0 <<= shift;
+					dest->ud.d1 <<= shift;
+				}
+				break;
+			case 0x02:  /*PSRLD*/
+				if (shift > 31) dest->q = 0;
+				else {
+					dest->ud.d0 >>= shift;
+					dest->ud.d1 >>= shift;
+				}
+				break;
+			case 0x04:  /*PSRAD*/
+				MMX_reg tmp;
+				if (!shift) break;
+				tmp.q = dest->q;
+				if (shift > 31) { 
+					dest->ud.d0 = (tmp.ud.d0&0x80000000)?0xffffffff:0;
+					dest->ud.d1 = (tmp.ud.d1&0x80000000)?0xffffffff:0;
+				} else {
+					dest->ud.d0 >>= shift;
+					dest->ud.d1 >>= shift;
+					if (tmp.ud.d0&0x80000000) dest->ud.d0 |= (0xffffffff << (32 - shift));
+					if (tmp.ud.d1&0x80000000) dest->ud.d1 |= (0xffffffff << (32 - shift));
+				}
+				break;
+		}
+		break;
+	}
+
+	CASE_0F_D(0xf3)												/* PSLLQ Pq,Qq */
+	{
+		GetRM;
+		MMX_reg* dest=lookupRMregMM[rm];
+		MMX_reg src;
+		if (rm>=0xc0) {
+			src.q=reg_mmx[rm&7].q;
+		} else {
+			GetEAa;
+			src.q=LoadMq(eaa);
+		}
+		if (src.q > 63) dest->q = 0;
+		else dest->q <<= src.ub.b0;
+		break;
+	}
+	CASE_0F_D(0xd3)												/* PSRLQ Pq,Qq */
+	{
+		GetRM;
+		MMX_reg* dest=lookupRMregMM[rm];
+		MMX_reg src;
+		if (rm>=0xc0) {
+			src.q=reg_mmx[rm&7].q;
+		} else {
+			GetEAa;
+			src.q=LoadMq(eaa);
+		}
+		if (src.q > 63) dest->q = 0;
+		else dest->q >>= src.ub.b0;
+		break;
+	}
+	CASE_0F_D(0x73)												/* PSLLQ/PSRLQ Pq,Ib */
+	{
+		GetRM;
+		Bit8u shift=Fetchb();
+		MMX_reg* dest=&reg_mmx[rm&7];
+		if (shift > 63) dest->q = 0;
+		else {
+			Bit8u op=rm&0x20;
+			if (op) {
+				dest->q <<= shift;
+			} else {
+				dest->q >>= shift;
+			}
+		}
+		break;
+	}
+
+/* Math */
+	CASE_0F_D(0xFC)												/* PADDB Pq,Qq */
+	{
+		GetRM;
+		MMX_reg* dest=lookupRMregMM[rm];
+		MMX_reg src;
+		if (rm>=0xc0) {
+			src.q=reg_mmx[rm&7].q;
+		} else {
+			GetEAa;
+			src.q = LoadMq(eaa);
+		}
+		dest->ub.b0 += src.ub.b0;
+		dest->ub.b1 += src.ub.b1;
+		dest->ub.b2 += src.ub.b2;
+		dest->ub.b3 += src.ub.b3;
+		dest->ub.b4 += src.ub.b4;
+		dest->ub.b5 += src.ub.b5;
+		dest->ub.b6 += src.ub.b6;
+		dest->ub.b7 += src.ub.b7;
+		break;
+	}
+	CASE_0F_D(0xFD)												/* PADDW Pq,Qq */
+	{
+		GetRM;
+		MMX_reg* dest=lookupRMregMM[rm];
+		MMX_reg src;
+		if (rm>=0xc0) {
+			src.q=reg_mmx[rm&7].q;
+		} else {
+			GetEAa;
+			src.q = LoadMq(eaa);
+		}
+		dest->uw.w0 += src.uw.w0;
+		dest->uw.w1 += src.uw.w1;
+		dest->uw.w2 += src.uw.w2;
+		dest->uw.w3 += src.uw.w3;
+		break;
+	}
+	CASE_0F_D(0xFE)												/* PADDD Pq,Qq */
+	{
+		GetRM;
+		MMX_reg* dest=lookupRMregMM[rm];
+		MMX_reg src;
+		if (rm>=0xc0) {
+			src.q=reg_mmx[rm&7].q;
+		} else {
+			GetEAa;
+			src.q = LoadMq(eaa);
+		}
+		dest->ud.d0 += src.ud.d0;
+		dest->ud.d1 += src.ud.d1;
+		break;
+	}
+	CASE_0F_D(0xEC)												/* PADDSB Pq,Qq */
+	{
+		GetRM;
+		MMX_reg* dest=lookupRMregMM[rm];
+		MMX_reg src;
+		if (rm>=0xc0) {
+			src.q = reg_mmx[rm&7].q;
+		} else {
+			GetEAa;
+			src.q = LoadMq(eaa);
+		}
+		dest->sb.b0 = SaturateWordSToByteS((Bit16s)dest->sb.b0+(Bit16s)src.sb.b0);
+		dest->sb.b1 = SaturateWordSToByteS((Bit16s)dest->sb.b1+(Bit16s)src.sb.b1);
+		dest->sb.b2 = SaturateWordSToByteS((Bit16s)dest->sb.b2+(Bit16s)src.sb.b2);
+		dest->sb.b3 = SaturateWordSToByteS((Bit16s)dest->sb.b3+(Bit16s)src.sb.b3);
+		dest->sb.b4 = SaturateWordSToByteS((Bit16s)dest->sb.b4+(Bit16s)src.sb.b4);
+		dest->sb.b5 = SaturateWordSToByteS((Bit16s)dest->sb.b5+(Bit16s)src.sb.b5);
+		dest->sb.b6 = SaturateWordSToByteS((Bit16s)dest->sb.b6+(Bit16s)src.sb.b6);
+		dest->sb.b7 = SaturateWordSToByteS((Bit16s)dest->sb.b7+(Bit16s)src.sb.b7);
+		break;
+	}
+	CASE_0F_D(0xED)												/* PADDSW Pq,Qq */
+	{
+		GetRM;
+		MMX_reg* dest=lookupRMregMM[rm];
+		MMX_reg src;
+		if (rm>=0xc0) {
+			src.q = reg_mmx[rm&7].q;
+		} else {
+			GetEAa;
+			src.q = LoadMq(eaa);
+		}
+		dest->sw.w0 = SaturateDwordSToWordS((Bit32s)dest->sw.w0+(Bit32s)src.sw.w0);
+		dest->sw.w1 = SaturateDwordSToWordS((Bit32s)dest->sw.w1+(Bit32s)src.sw.w1);
+		dest->sw.w2 = SaturateDwordSToWordS((Bit32s)dest->sw.w2+(Bit32s)src.sw.w2);
+		dest->sw.w3 = SaturateDwordSToWordS((Bit32s)dest->sw.w3+(Bit32s)src.sw.w3);
+		break;
+	}
+	CASE_0F_D(0xDC)												/* PADDUSB Pq,Qq */
+	{
+		GetRM;
+		MMX_reg* dest=lookupRMregMM[rm];
+		MMX_reg src;
+		if (rm>=0xc0) {
+			src.q = reg_mmx[rm&7].q;
+		} else {
+			GetEAa;
+			src.q = LoadMq(eaa);
+		}
+		dest->ub.b0 = SaturateWordSToByteU((Bit16s)dest->ub.b0+(Bit16s)src.ub.b0);
+		dest->ub.b1 = SaturateWordSToByteU((Bit16s)dest->ub.b1+(Bit16s)src.ub.b1);
+		dest->ub.b2 = SaturateWordSToByteU((Bit16s)dest->ub.b2+(Bit16s)src.ub.b2);
+		dest->ub.b3 = SaturateWordSToByteU((Bit16s)dest->ub.b3+(Bit16s)src.ub.b3);
+		dest->ub.b4 = SaturateWordSToByteU((Bit16s)dest->ub.b4+(Bit16s)src.ub.b4);
+		dest->ub.b5 = SaturateWordSToByteU((Bit16s)dest->ub.b5+(Bit16s)src.ub.b5);
+		dest->ub.b6 = SaturateWordSToByteU((Bit16s)dest->ub.b6+(Bit16s)src.ub.b6);
+		dest->ub.b7 = SaturateWordSToByteU((Bit16s)dest->ub.b7+(Bit16s)src.ub.b7);
+		break;
+	}
+	CASE_0F_D(0xDD)												/* PADDUSW Pq,Qq */
+	{
+		GetRM;
+		MMX_reg* dest=lookupRMregMM[rm];
+		MMX_reg src;
+		if (rm>=0xc0) {
+			src.q = reg_mmx[rm&7].q;
+		} else {
+			GetEAa;
+			src.q = LoadMq(eaa);
+		}
+		dest->uw.w0 = SaturateDwordSToWordU((Bit32s)dest->uw.w0+(Bit32s)src.uw.w0);
+		dest->uw.w1 = SaturateDwordSToWordU((Bit32s)dest->uw.w1+(Bit32s)src.uw.w1);
+		dest->uw.w2 = SaturateDwordSToWordU((Bit32s)dest->uw.w2+(Bit32s)src.uw.w2);
+		dest->uw.w3 = SaturateDwordSToWordU((Bit32s)dest->uw.w3+(Bit32s)src.uw.w3);
+		break;
+	}
+	CASE_0F_D(0xF8)												/* PSUBB Pq,Qq */
+	{
+		GetRM;
+		MMX_reg* dest=lookupRMregMM[rm];
+		MMX_reg src;
+		if (rm>=0xc0) {
+			src.q=reg_mmx[rm&7].q;
+		} else {
+			GetEAa;
+			src.q = LoadMq(eaa);
+		}
+		dest->ub.b0 -= src.ub.b0;
+		dest->ub.b1 -= src.ub.b1;
+		dest->ub.b2 -= src.ub.b2;
+		dest->ub.b3 -= src.ub.b3;
+		dest->ub.b4 -= src.ub.b4;
+		dest->ub.b5 -= src.ub.b5;
+		dest->ub.b6 -= src.ub.b6;
+		dest->ub.b7 -= src.ub.b7;
+		break;
+	}
+	CASE_0F_D(0xF9)												/* PSUBW Pq,Qq */
+	{
+		GetRM;
+		MMX_reg* dest=lookupRMregMM[rm];
+		MMX_reg src;
+		if (rm>=0xc0) {
+			src.q=reg_mmx[rm&7].q;
+		} else {
+			GetEAa;
+			src.q = LoadMq(eaa);
+		}
+		dest->uw.w0 -= src.uw.w0;
+		dest->uw.w1 -= src.uw.w1;
+		dest->uw.w2 -= src.uw.w2;
+		dest->uw.w3 -= src.uw.w3;
+		break;
+	}
+	CASE_0F_D(0xFA)												/* PSUBD Pq,Qq */
+	{
+		GetRM;
+		MMX_reg* dest=lookupRMregMM[rm];
+		MMX_reg src;
+		if (rm>=0xc0) {
+			src.q=reg_mmx[rm&7].q;
+		} else {
+			GetEAa;
+			src.q = LoadMq(eaa);
+		}
+		dest->ud.d0 -= src.ud.d0;
+		dest->ud.d1 -= src.ud.d1;
+		break;
+	}
+	CASE_0F_D(0xE8)												/* PSUBSB Pq,Qq */
+	{
+		GetRM;
+		MMX_reg* dest=lookupRMregMM[rm];
+		MMX_reg src;
+		if (rm>=0xc0) {
+			src.q = reg_mmx[rm&7].q;
+		} else {
+			GetEAa;
+			src.q = LoadMq(eaa);
+		}
+		dest->sb.b0 = SaturateWordSToByteS((Bit16s)dest->sb.b0-(Bit16s)src.sb.b0);
+		dest->sb.b1 = SaturateWordSToByteS((Bit16s)dest->sb.b1-(Bit16s)src.sb.b1);
+		dest->sb.b2 = SaturateWordSToByteS((Bit16s)dest->sb.b2-(Bit16s)src.sb.b2);
+		dest->sb.b3 = SaturateWordSToByteS((Bit16s)dest->sb.b3-(Bit16s)src.sb.b3);
+		dest->sb.b4 = SaturateWordSToByteS((Bit16s)dest->sb.b4-(Bit16s)src.sb.b4);
+		dest->sb.b5 = SaturateWordSToByteS((Bit16s)dest->sb.b5-(Bit16s)src.sb.b5);
+		dest->sb.b6 = SaturateWordSToByteS((Bit16s)dest->sb.b6-(Bit16s)src.sb.b6);
+		dest->sb.b7 = SaturateWordSToByteS((Bit16s)dest->sb.b7-(Bit16s)src.sb.b7);
+		break;
+	}
+	CASE_0F_D(0xE9)												/* PSUBSW Pq,Qq */
+	{
+		GetRM;
+		MMX_reg* dest=lookupRMregMM[rm];
+		MMX_reg src;
+		if (rm>=0xc0) {
+			src.q = reg_mmx[rm&7].q;
+		} else {
+			GetEAa;
+			src.q = LoadMq(eaa);
+		}
+		dest->sw.w0 = SaturateDwordSToWordS((Bit32s)dest->sw.w0-(Bit32s)src.sw.w0);
+		dest->sw.w1 = SaturateDwordSToWordS((Bit32s)dest->sw.w1-(Bit32s)src.sw.w1);
+		dest->sw.w2 = SaturateDwordSToWordS((Bit32s)dest->sw.w2-(Bit32s)src.sw.w2);
+		dest->sw.w3 = SaturateDwordSToWordS((Bit32s)dest->sw.w3-(Bit32s)src.sw.w3);
+		break;
+	}
+	CASE_0F_D(0xD8)												/* PSUBUSB Pq,Qq */
+	{
+		GetRM;
+		MMX_reg* dest=lookupRMregMM[rm];
+		MMX_reg src;
+		MMX_reg result;
+		if (rm>=0xc0) {
+			src.q = reg_mmx[rm&7].q;
+		} else {
+			GetEAa;
+			src.q = LoadMq(eaa);
+		}
+		result.q = 0;
+		if (dest->ub.b0>src.ub.b0) result.ub.b0 = dest->ub.b0 - src.ub.b0;
+		if (dest->ub.b1>src.ub.b1) result.ub.b1 = dest->ub.b1 - src.ub.b1;
+		if (dest->ub.b2>src.ub.b2) result.ub.b2 = dest->ub.b2 - src.ub.b2;
+		if (dest->ub.b3>src.ub.b3) result.ub.b3 = dest->ub.b3 - src.ub.b3;
+		if (dest->ub.b4>src.ub.b4) result.ub.b4 = dest->ub.b4 - src.ub.b4;
+		if (dest->ub.b5>src.ub.b5) result.ub.b5 = dest->ub.b5 - src.ub.b5;
+		if (dest->ub.b6>src.ub.b6) result.ub.b6 = dest->ub.b6 - src.ub.b6;
+		if (dest->ub.b7>src.ub.b7) result.ub.b7 = dest->ub.b7 - src.ub.b7;
+		dest->q = result.q;
+		break;
+	}
+
+	CASE_0F_D(0xD9)												/* PSUBUSW Pq,Qq */
+	{
+		GetRM;
+		MMX_reg* dest=lookupRMregMM[rm];
+		MMX_reg src;
+		MMX_reg result;
+		if (rm>=0xc0) {
+			src.q = reg_mmx[rm&7].q;
+		} else {
+			GetEAa;
+			src.q = LoadMq(eaa);
+		}
+		result.q = 0;
+		if (dest->uw.w0>src.uw.w0) result.uw.w0 = dest->uw.w0 - src.uw.w0;
+		if (dest->uw.w1>src.uw.w1) result.uw.w1 = dest->uw.w1 - src.uw.w1;
+		if (dest->uw.w2>src.uw.w2) result.uw.w2 = dest->uw.w2 - src.uw.w2;
+		if (dest->uw.w3>src.uw.w3) result.uw.w3 = dest->uw.w3 - src.uw.w3;
+		dest->q = result.q;
+		break;
+	}
+	CASE_0F_D(0xE5)												/* PMULHW Pq,Qq */
+	{
+		GetRM;
+		MMX_reg* dest=lookupRMregMM[rm];
+		MMX_reg src;
+		if (rm>=0xc0) {
+			src.q = reg_mmx[rm&7].q;
+		} else {
+			GetEAa;
+			src.q = LoadMq(eaa);
+		}
+		Bit32s product0 = (Bit32s)dest->sw.w0 * (Bit32s)src.sw.w0;
+		Bit32s product1 = (Bit32s)dest->sw.w1 * (Bit32s)src.sw.w1;
+		Bit32s product2 = (Bit32s)dest->sw.w2 * (Bit32s)src.sw.w2;
+		Bit32s product3 = (Bit32s)dest->sw.w3 * (Bit32s)src.sw.w3;
+		dest->uw.w0 = (Bit16u)(product0 >> 16);
+		dest->uw.w1 = (Bit16u)(product1 >> 16);
+		dest->uw.w2 = (Bit16u)(product2 >> 16);
+		dest->uw.w3 = (Bit16u)(product3 >> 16);
+		break;
+	}
+	CASE_0F_D(0xD5)												/* PMULLW Pq,Qq */
+	{
+		GetRM;
+		MMX_reg* dest=lookupRMregMM[rm];
+		MMX_reg src;
+		if (rm>=0xc0) {
+			src.q = reg_mmx[rm&7].q;
+		} else {
+			GetEAa;
+			src.q = LoadMq(eaa);
+		}
+		Bit32u product0 = (Bit32u)dest->uw.w0 * (Bit32u)src.uw.w0;
+		Bit32u product1 = (Bit32u)dest->uw.w1 * (Bit32u)src.uw.w1;
+		Bit32u product2 = (Bit32u)dest->uw.w2 * (Bit32u)src.uw.w2;
+		Bit32u product3 = (Bit32u)dest->uw.w3 * (Bit32u)src.uw.w3;
+		dest->uw.w0 = (product0 & 0xffff);
+		dest->uw.w1 = (product1 & 0xffff);
+		dest->uw.w2 = (product2 & 0xffff);
+		dest->uw.w3 = (product3 & 0xffff);
+		break;
+	}
+	CASE_0F_D(0xF5)												/* PMADDWD Pq,Qq */
+	{
+		GetRM;
+		MMX_reg* dest=lookupRMregMM[rm];
+		MMX_reg src;
+		if (rm>=0xc0) {
+			src.q = reg_mmx[rm&7].q;
+		} else {
+			GetEAa;
+			src.q = LoadMq(eaa);
+		}
+		if (dest->ud.d0 == 0x80008000 && src.ud.d0 == 0x80008000)
+			dest->ud.d0 = 0x80000000;
+		else {
+			Bit32s product0 = (Bit32s)dest->sw.w0 * (Bit32s)src.sw.w0;
+			Bit32s product1 = (Bit32s)dest->sw.w1 * (Bit32s)src.sw.w1;
+			dest->ud.d0 = product0 + product1;
+		}
+		if (dest->ud.d1 == 0x80008000 && src.ud.d1 == 0x80008000)
+			dest->ud.d1 = 0x80000000;
+		else {
+			Bit32s product2 = (Bit32s)dest->sw.w2 * (Bit32s)src.sw.w2;
+			Bit32s product3 = (Bit32s)dest->sw.w3 * (Bit32s)src.sw.w3;
+			dest->sd.d1 = product2 + product3;
+		}
+		break;
+	}
+
+/* Comparison */
+	CASE_0F_D(0x74)												/* PCMPEQB Pq,Qq */
+	{
+		GetRM;
+		MMX_reg* dest=lookupRMregMM[rm];
+		MMX_reg src;
+		if (rm>=0xc0) {
+			src.q=reg_mmx[rm&7].q;
+		} else {
+			GetEAa;
+			src.q = LoadMq(eaa);
+		}
+		dest->ub.b0 = dest->ub.b0==src.ub.b0?0xff:0;
+		dest->ub.b1 = dest->ub.b1==src.ub.b1?0xff:0;
+		dest->ub.b2 = dest->ub.b2==src.ub.b2?0xff:0;
+		dest->ub.b3 = dest->ub.b3==src.ub.b3?0xff:0;
+		dest->ub.b4 = dest->ub.b4==src.ub.b4?0xff:0;
+		dest->ub.b5 = dest->ub.b5==src.ub.b5?0xff:0;
+		dest->ub.b6 = dest->ub.b6==src.ub.b6?0xff:0;
+		dest->ub.b7 = dest->ub.b7==src.ub.b7?0xff:0;
+		break;
+	}
+	CASE_0F_D(0x75)												/* PCMPEQW Pq,Qq */
+	{
+		GetRM;
+		MMX_reg* dest=lookupRMregMM[rm];
+		MMX_reg src;
+		if (rm>=0xc0) {
+			src.q=reg_mmx[rm&7].q;
+		} else {
+			GetEAa;
+			src.q = LoadMq(eaa);
+		}
+		dest->uw.w0 = dest->uw.w0==src.uw.w0?0xffff:0;
+		dest->uw.w1 = dest->uw.w1==src.uw.w1?0xffff:0;
+		dest->uw.w2 = dest->uw.w2==src.uw.w2?0xffff:0;
+		dest->uw.w3 = dest->uw.w3==src.uw.w3?0xffff:0;
+		break;
+	}
+	CASE_0F_D(0x76)												/* PCMPEQD Pq,Qq */
+	{
+		GetRM;
+		MMX_reg* dest=lookupRMregMM[rm];
+		MMX_reg src;
+		if (rm>=0xc0) {
+			src.q=reg_mmx[rm&7].q;
+		} else {
+			GetEAa;
+			src.q = LoadMq(eaa);
+		}
+		dest->ud.d0 = dest->ud.d0==src.ud.d0?0xffffffff:0;
+		dest->ud.d1 = dest->ud.d1==src.ud.d1?0xffffffff:0;
+		break;
+	}
+	CASE_0F_D(0x64)												/* PCMPGTB Pq,Qq */
+	{
+		GetRM;
+		MMX_reg* dest=lookupRMregMM[rm];
+		MMX_reg src;
+		if (rm>=0xc0) {
+			src.q=reg_mmx[rm&7].q;
+		} else {
+			GetEAa;
+			src.q = LoadMq(eaa);
+		}
+		dest->ub.b0 = dest->sb.b0>src.sb.b0?0xff:0;
+		dest->ub.b1 = dest->sb.b1>src.sb.b1?0xff:0;
+		dest->ub.b2 = dest->sb.b2>src.sb.b2?0xff:0;
+		dest->ub.b3 = dest->sb.b3>src.sb.b3?0xff:0;
+		dest->ub.b4 = dest->sb.b4>src.sb.b4?0xff:0;
+		dest->ub.b5 = dest->sb.b5>src.sb.b5?0xff:0;
+		dest->ub.b6 = dest->sb.b6>src.sb.b6?0xff:0;
+		dest->ub.b7 = dest->sb.b7>src.sb.b7?0xff:0;
+		break;
+	}
+	CASE_0F_D(0x65)												/* PCMPGTW Pq,Qq */
+	{
+		GetRM;
+		MMX_reg* dest=lookupRMregMM[rm];
+		MMX_reg src;
+		if (rm>=0xc0) {
+			src.q=reg_mmx[rm&7].q;
+		} else {
+			GetEAa;
+			src.q = LoadMq(eaa);
+		}
+		dest->uw.w0 = dest->sw.w0>src.sw.w0?0xffff:0;
+		dest->uw.w1 = dest->sw.w1>src.sw.w1?0xffff:0;
+		dest->uw.w2 = dest->sw.w2>src.sw.w2?0xffff:0;
+		dest->uw.w3 = dest->sw.w3>src.sw.w3?0xffff:0;
+		break;
+	}
+	CASE_0F_D(0x66)												/* PCMPGTD Pq,Qq */
+	{
+		GetRM;
+		MMX_reg* dest=lookupRMregMM[rm];
+		MMX_reg src;
+		if (rm>=0xc0) {
+			src.q=reg_mmx[rm&7].q;
+		} else {
+			GetEAa;
+			src.q = LoadMq(eaa);
+		}
+		dest->ud.d0 = dest->sd.d0>src.sd.d0?0xffffffff:0;
+		dest->ud.d1 = dest->sd.d1>src.sd.d1?0xffffffff:0;
+		break;
+	}
+
+/* Data Packing */
+	CASE_0F_D(0x63)												/* PACKSSWB Pq,Qq */
+	{
+		GetRM;
+		MMX_reg* dest=lookupRMregMM[rm];
+		MMX_reg src;
+		if (rm>=0xc0) {
+			src.q=reg_mmx[rm&7].q;
+		} else {
+			GetEAa;
+			src.q = LoadMq(eaa);
+		}
+		dest->sb.b0 = SaturateWordSToByteS(dest->sw.w0);
+		dest->sb.b1 = SaturateWordSToByteS(dest->sw.w1);
+		dest->sb.b2 = SaturateWordSToByteS(dest->sw.w2);
+		dest->sb.b3 = SaturateWordSToByteS(dest->sw.w3);
+		dest->sb.b4 = SaturateWordSToByteS(src.sw.w0);
+		dest->sb.b5 = SaturateWordSToByteS(src.sw.w1);
+		dest->sb.b6 = SaturateWordSToByteS(src.sw.w2);
+		dest->sb.b7 = SaturateWordSToByteS(src.sw.w3);
+		break;
+	}
+	CASE_0F_D(0x6B)												/* PACKSSDW Pq,Qq */
+	{
+		GetRM;
+		MMX_reg* dest=lookupRMregMM[rm];
+		MMX_reg src;
+		if (rm>=0xc0) {
+			src.q=reg_mmx[rm&7].q;
+		} else {
+			GetEAa;
+			src.q = LoadMq(eaa);
+		}
+		dest->sw.w0 = SaturateDwordSToWordS(dest->sd.d0);
+		dest->sw.w1 = SaturateDwordSToWordS(dest->sd.d1);
+		dest->sw.w2 = SaturateDwordSToWordS(src.sd.d0);
+		dest->sw.w3 = SaturateDwordSToWordS(src.sd.d1);
+		break;
+	}
+	CASE_0F_D(0x67)												/* PACKUSWB Pq,Qq */
+	{
+		GetRM;
+		MMX_reg* dest=lookupRMregMM[rm];
+		MMX_reg src;
+		if (rm>=0xc0) {
+			src.q=reg_mmx[rm&7].q;
+		} else {
+			GetEAa;
+			src.q = LoadMq(eaa);
+		}
+		dest->ub.b0 = SaturateWordSToByteU(dest->sw.w0);
+		dest->ub.b1 = SaturateWordSToByteU(dest->sw.w1);
+		dest->ub.b2 = SaturateWordSToByteU(dest->sw.w2);
+		dest->ub.b3 = SaturateWordSToByteU(dest->sw.w3);
+		dest->ub.b4 = SaturateWordSToByteU(src.sw.w0);
+		dest->ub.b5 = SaturateWordSToByteU(src.sw.w1);
+		dest->ub.b6 = SaturateWordSToByteU(src.sw.w2);
+		dest->ub.b7 = SaturateWordSToByteU(src.sw.w3);
+		break;
+	}
+	CASE_0F_D(0x68)												/* PUNPCKHBW Pq,Qq */
+	{
+		GetRM;
+		MMX_reg* dest=lookupRMregMM[rm];
+		MMX_reg src;
+		if (rm>=0xc0) {
+			src.q=reg_mmx[rm&7].q;
+		} else {
+			GetEAa;
+			src.q = LoadMq(eaa);
+		}
+		dest->ub.b0 = dest->ub.b4;
+		dest->ub.b1 = src.ub.b4;
+		dest->ub.b2 = dest->ub.b5;
+		dest->ub.b3 = src.ub.b5;
+		dest->ub.b4 = dest->ub.b6;
+		dest->ub.b5 = src.ub.b6;
+		dest->ub.b6 = dest->ub.b7;
+		dest->ub.b7 = src.ub.b7;
+		break;
+	}
+	CASE_0F_D(0x69)												/* PUNPCKHWD Pq,Qq */
+	{
+		GetRM;
+		MMX_reg* dest=lookupRMregMM[rm];
+		MMX_reg src;
+		if (rm>=0xc0) {
+			src.q=reg_mmx[rm&7].q;
+		} else {
+			GetEAa;
+			src.q = LoadMq(eaa);
+		}
+		dest->uw.w0 = dest->uw.w2;
+		dest->uw.w1 = src.uw.w2;
+		dest->uw.w2 = dest->uw.w3;
+		dest->uw.w3 = src.uw.w3;
+		break;
+	}
+	CASE_0F_D(0x6A)												/* PUNPCKHDQ Pq,Qq */
+	{
+		GetRM;
+		MMX_reg* dest=lookupRMregMM[rm];
+		MMX_reg src;
+		if (rm>=0xc0) {
+			src.q=reg_mmx[rm&7].q;
+		} else {
+			GetEAa;
+			src.q = LoadMq(eaa);
+		}
+		dest->ud.d0 = dest->ud.d1;
+		dest->ud.d1 = src.ud.d1;
+		break;
+	}
+	CASE_0F_D(0x60)												/* PUNPCKLBW Pq,Qq */
+	{
+		GetRM;
+		MMX_reg* dest=lookupRMregMM[rm];
+		MMX_reg src;
+		if (rm>=0xc0) {
+			src.q=reg_mmx[rm&7].q;
+		} else {
+			GetEAa;
+			src.q = LoadMq(eaa);
+		}
+		dest->ub.b7 = src.ub.b3;
+		dest->ub.b6 = dest->ub.b3;
+		dest->ub.b5 = src.ub.b2;
+		dest->ub.b4 = dest->ub.b2;
+		dest->ub.b3 = src.ub.b1;
+		dest->ub.b2 = dest->ub.b1;
+		dest->ub.b1 = src.ub.b0;
+		dest->ub.b0 = dest->ub.b0;
+		break;
+	}
+	CASE_0F_D(0x61)												/* PUNPCKLWD Pq,Qq */
+	{
+		GetRM;
+		MMX_reg* dest=lookupRMregMM[rm];
+		MMX_reg src;
+		if (rm>=0xc0) {
+			src.q=reg_mmx[rm&7].q;
+		} else {
+			GetEAa;
+			src.q = LoadMq(eaa);
+		}
+		dest->uw.w3 = src.uw.w1;
+		dest->uw.w2 = dest->uw.w1;
+		dest->uw.w1 = src.uw.w0;
+		dest->uw.w0 = dest->uw.w0;
+		break;
+	}
+	CASE_0F_D(0x62)												/* PUNPCKLDQ Pq,Qq */
+	{
+		GetRM;
+		MMX_reg* dest=lookupRMregMM[rm];
+		MMX_reg src;
+		if (rm>=0xc0) {
+			src.q=reg_mmx[rm&7].q;
+		} else {
+			GetEAa;
+			src.q = LoadMq(eaa);
+		}
+		dest->ud.d1 = src.ud.d0;
+		break;
+	}
diff -urN dosbox_orig/src/cpu/core_normal/prefix_66_0f.h dosbox/src/cpu/core_normal/prefix_66_0f.h
--- dosbox_orig/src/cpu/core_normal/prefix_66_0f.h	2011-04-26 10:34:55.000000000 +0200
+++ dosbox/src/cpu/core_normal/prefix_66_0f.h	2011-12-27 21:07:07.000000000 +0100
@@ -463,3 +463,6 @@
 	CASE_0F_D(0xcf)												/* BSWAP EDI */
 		if (CPU_ArchitectureType<CPU_ARCHTYPE_486OLDSLOW) goto illegal_opcode;
 		BSWAPD(reg_edi);break;
+#if C_MMX
+#include "prefix_0f_mmx.h"
+#endif
\ No newline at end of file
diff -urN dosbox_orig/src/cpu/core_normal.cpp dosbox/src/cpu/core_normal.cpp
--- dosbox_orig/src/cpu/core_normal.cpp	2011-04-26 10:34:55.000000000 +0200
+++ dosbox/src/cpu/core_normal.cpp	2011-12-25 18:44:53.000000000 +0100
@@ -27,6 +27,7 @@
 #include "pic.h"
 #include "fpu.h"
 #include "paging.h"
+#include "mmx.h"
 
 #if C_DEBUG
 #include "debug.h"
@@ -36,9 +37,11 @@
 #define LoadMb(off) mem_readb(off)
 #define LoadMw(off) mem_readw(off)
 #define LoadMd(off) mem_readd(off)
+#define LoadMq(off) ((Bit64u)((Bit64u)mem_readd(off+4)<<32 | (Bit64u)mem_readd(off)))
 #define SaveMb(off,val)	mem_writeb(off,val)
 #define SaveMw(off,val)	mem_writew(off,val)
 #define SaveMd(off,val)	mem_writed(off,val)
+#define SaveMq(off,val) {mem_writed(off,val&0xffffffff);mem_writed(off+4,(val>>32)&0xffffffff);}
 #else 
 #include "paging.h"
 #define LoadMb(off) mem_readb_inline(off)
diff -urN dosbox_orig/src/cpu/core_prefetch.cpp dosbox/src/cpu/core_prefetch.cpp
--- dosbox_orig/src/cpu/core_prefetch.cpp	2011-04-26 10:34:55.000000000 +0200
+++ dosbox/src/cpu/core_prefetch.cpp	2011-12-23 21:00:23.000000000 +0100
@@ -28,6 +28,7 @@
 #include "pic.h"
 #include "fpu.h"
 #include "paging.h"
+#include "mmx.h"
 
 #if C_DEBUG
 #include "debug.h"
@@ -37,9 +38,11 @@
 #define LoadMb(off) mem_readb(off)
 #define LoadMw(off) mem_readw(off)
 #define LoadMd(off) mem_readd(off)
+#define LoadMq(off) ((Bit64u)((Bit64u)mem_readd(off+4)<<32 | (Bit64u)mem_readd(off)))
 #define SaveMb(off,val)	mem_writeb(off,val)
 #define SaveMw(off,val)	mem_writew(off,val)
 #define SaveMd(off,val)	mem_writed(off,val)
+#define SaveMq(off,val) {mem_writed(off,val&0xffffffff);mem_writed(off+4,(val>>32)&0xffffffff);}
 #else 
 #include "paging.h"
 #define LoadMb(off) mem_readb_inline(off)
diff -urN dosbox_orig/src/cpu/core_simple.cpp dosbox/src/cpu/core_simple.cpp
--- dosbox_orig/src/cpu/core_simple.cpp	2011-04-26 10:34:55.000000000 +0200
+++ dosbox/src/cpu/core_simple.cpp	2011-12-23 21:00:23.000000000 +0100
@@ -26,6 +26,7 @@
 #include "callback.h"
 #include "pic.h"
 #include "fpu.h"
+#include "mmx.h"
 
 #if C_DEBUG
 #include "debug.h"
@@ -36,10 +37,12 @@
 #define LoadMb(off) mem_readb(off)
 #define LoadMw(off) mem_readw(off)
 #define LoadMd(off) mem_readd(off)
+#define LoadMq(off) ((Bit64u)((Bit64u)mem_readd(off+4)<<32 | (Bit64u)mem_readd(off)))
 
 #define SaveMb(off,val)	mem_writeb(off,val)
 #define SaveMw(off,val)	mem_writew(off,val)
 #define SaveMd(off,val)	mem_writed(off,val)
+#define SaveMq(off,val) {mem_writed(off,val&0xffffffff);mem_writed(off+4,(val>>32)&0xffffffff);}
 
 extern Bitu cycle_count;
 
diff -urN dosbox_orig/src/cpu/cpu.cpp dosbox/src/cpu/cpu.cpp
--- dosbox_orig/src/cpu/cpu.cpp	2011-11-20 18:32:09.000000000 +0100
+++ dosbox/src/cpu/cpu.cpp	2011-12-21 22:39:19.000000000 +0100
@@ -2029,6 +2029,13 @@
 			reg_ebx=0;			/* Not Supported */
 			reg_ecx=0;			/* No features */
 			reg_edx=0x00000011;	/* FPU+TimeStamp/RDTSC */
+#if C_MMX
+		} else if (CPU_ArchitectureType==CPU_ARCHTYPE_P55CSLOW) {
+			reg_eax=0x543;		/* intel pentium mmx (P55C) */
+			reg_ebx=0;			/* Not Supported */
+			reg_ecx=0;			/* No features */
+			reg_edx=0x00800011;	/* FPU+TimeStamp/RDTSC+MMX */
+#endif
 		} else {
 			return false;
 		}
@@ -2211,7 +2218,7 @@
 			cpu.drx[i]=0;
 			cpu.trx[i]=0;
 		}
-		if (CPU_ArchitectureType==CPU_ARCHTYPE_PENTIUMSLOW) {
+		if (CPU_ArchitectureType>=CPU_ARCHTYPE_PENTIUMSLOW) {
 			cpu.drx[6]=0xffff0ff0;
 		} else {
 			cpu.drx[6]=0xffff1ff0;
@@ -2388,6 +2395,8 @@
 			}
 		} else if (cputype == "pentium_slow") {
 			CPU_ArchitectureType = CPU_ARCHTYPE_PENTIUMSLOW;
+		} else if (cputype == "pentium_mmx_slow") {
+			CPU_ArchitectureType = CPU_ARCHTYPE_P55CSLOW;
 		}
 
 		if (CPU_ArchitectureType>=CPU_ARCHTYPE_486NEWSLOW) CPU_extflags_toggle=(FLAG_ID|FLAG_AC);
diff -urN dosbox_orig/src/cpu/mmx.cpp dosbox/src/cpu/mmx.cpp
--- dosbox_orig/src/cpu/mmx.cpp	1970-01-01 01:00:00.000000000 +0100
+++ dosbox/src/cpu/mmx.cpp	2011-12-27 14:33:01.000000000 +0100
@@ -0,0 +1,101 @@
+/*
+ *  Copyright (C) 2002-2011  The DOSBox Team
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+
+#include "dosbox.h"
+
+#include "mem.h"
+#include "mmx.h"
+#include "cpu.h"
+#include "fpu.h"
+
+MMX_reg reg_mmx[8];
+
+
+MMX_reg * lookupRMregMM[256]={
+	&reg_mmx[0],&reg_mmx[0],&reg_mmx[0],&reg_mmx[0],&reg_mmx[0],&reg_mmx[0],&reg_mmx[0],&reg_mmx[0],
+	&reg_mmx[1],&reg_mmx[1],&reg_mmx[1],&reg_mmx[1],&reg_mmx[1],&reg_mmx[1],&reg_mmx[1],&reg_mmx[1],
+	&reg_mmx[2],&reg_mmx[2],&reg_mmx[2],&reg_mmx[2],&reg_mmx[2],&reg_mmx[2],&reg_mmx[2],&reg_mmx[2],
+	&reg_mmx[3],&reg_mmx[3],&reg_mmx[3],&reg_mmx[3],&reg_mmx[3],&reg_mmx[3],&reg_mmx[3],&reg_mmx[3],
+	&reg_mmx[4],&reg_mmx[4],&reg_mmx[4],&reg_mmx[4],&reg_mmx[4],&reg_mmx[4],&reg_mmx[4],&reg_mmx[4],
+	&reg_mmx[5],&reg_mmx[5],&reg_mmx[5],&reg_mmx[5],&reg_mmx[5],&reg_mmx[5],&reg_mmx[5],&reg_mmx[5],
+	&reg_mmx[6],&reg_mmx[6],&reg_mmx[6],&reg_mmx[6],&reg_mmx[6],&reg_mmx[6],&reg_mmx[6],&reg_mmx[6],
+	&reg_mmx[7],&reg_mmx[7],&reg_mmx[7],&reg_mmx[7],&reg_mmx[7],&reg_mmx[7],&reg_mmx[7],&reg_mmx[7],
+
+	&reg_mmx[0],&reg_mmx[0],&reg_mmx[0],&reg_mmx[0],&reg_mmx[0],&reg_mmx[0],&reg_mmx[0],&reg_mmx[0],
+	&reg_mmx[1],&reg_mmx[1],&reg_mmx[1],&reg_mmx[1],&reg_mmx[1],&reg_mmx[1],&reg_mmx[1],&reg_mmx[1],
+	&reg_mmx[2],&reg_mmx[2],&reg_mmx[2],&reg_mmx[2],&reg_mmx[2],&reg_mmx[2],&reg_mmx[2],&reg_mmx[2],
+	&reg_mmx[3],&reg_mmx[3],&reg_mmx[3],&reg_mmx[3],&reg_mmx[3],&reg_mmx[3],&reg_mmx[3],&reg_mmx[3],
+	&reg_mmx[4],&reg_mmx[4],&reg_mmx[4],&reg_mmx[4],&reg_mmx[4],&reg_mmx[4],&reg_mmx[4],&reg_mmx[4],
+	&reg_mmx[5],&reg_mmx[5],&reg_mmx[5],&reg_mmx[5],&reg_mmx[5],&reg_mmx[5],&reg_mmx[5],&reg_mmx[5],
+	&reg_mmx[6],&reg_mmx[6],&reg_mmx[6],&reg_mmx[6],&reg_mmx[6],&reg_mmx[6],&reg_mmx[6],&reg_mmx[6],
+	&reg_mmx[7],&reg_mmx[7],&reg_mmx[7],&reg_mmx[7],&reg_mmx[7],&reg_mmx[7],&reg_mmx[7],&reg_mmx[7],
+
+	&reg_mmx[0],&reg_mmx[0],&reg_mmx[0],&reg_mmx[0],&reg_mmx[0],&reg_mmx[0],&reg_mmx[0],&reg_mmx[0],
+	&reg_mmx[1],&reg_mmx[1],&reg_mmx[1],&reg_mmx[1],&reg_mmx[1],&reg_mmx[1],&reg_mmx[1],&reg_mmx[1],
+	&reg_mmx[2],&reg_mmx[2],&reg_mmx[2],&reg_mmx[2],&reg_mmx[2],&reg_mmx[2],&reg_mmx[2],&reg_mmx[2],
+	&reg_mmx[3],&reg_mmx[3],&reg_mmx[3],&reg_mmx[3],&reg_mmx[3],&reg_mmx[3],&reg_mmx[3],&reg_mmx[3],
+	&reg_mmx[4],&reg_mmx[4],&reg_mmx[4],&reg_mmx[4],&reg_mmx[4],&reg_mmx[4],&reg_mmx[4],&reg_mmx[4],
+	&reg_mmx[5],&reg_mmx[5],&reg_mmx[5],&reg_mmx[5],&reg_mmx[5],&reg_mmx[5],&reg_mmx[5],&reg_mmx[5],
+	&reg_mmx[6],&reg_mmx[6],&reg_mmx[6],&reg_mmx[6],&reg_mmx[6],&reg_mmx[6],&reg_mmx[6],&reg_mmx[6],
+	&reg_mmx[7],&reg_mmx[7],&reg_mmx[7],&reg_mmx[7],&reg_mmx[7],&reg_mmx[7],&reg_mmx[7],&reg_mmx[7],
+
+	&reg_mmx[0],&reg_mmx[0],&reg_mmx[0],&reg_mmx[0],&reg_mmx[0],&reg_mmx[0],&reg_mmx[0],&reg_mmx[0],
+	&reg_mmx[1],&reg_mmx[1],&reg_mmx[1],&reg_mmx[1],&reg_mmx[1],&reg_mmx[1],&reg_mmx[1],&reg_mmx[1],
+	&reg_mmx[2],&reg_mmx[2],&reg_mmx[2],&reg_mmx[2],&reg_mmx[2],&reg_mmx[2],&reg_mmx[2],&reg_mmx[2],
+	&reg_mmx[3],&reg_mmx[3],&reg_mmx[3],&reg_mmx[3],&reg_mmx[3],&reg_mmx[3],&reg_mmx[3],&reg_mmx[3],
+	&reg_mmx[4],&reg_mmx[4],&reg_mmx[4],&reg_mmx[4],&reg_mmx[4],&reg_mmx[4],&reg_mmx[4],&reg_mmx[4],
+	&reg_mmx[5],&reg_mmx[5],&reg_mmx[5],&reg_mmx[5],&reg_mmx[5],&reg_mmx[5],&reg_mmx[5],&reg_mmx[5],
+	&reg_mmx[6],&reg_mmx[6],&reg_mmx[6],&reg_mmx[6],&reg_mmx[6],&reg_mmx[6],&reg_mmx[6],&reg_mmx[6],
+	&reg_mmx[7],&reg_mmx[7],&reg_mmx[7],&reg_mmx[7],&reg_mmx[7],&reg_mmx[7],&reg_mmx[7],&reg_mmx[7],
+};
+
+
+Bit8s SaturateWordSToByteS(Bit16s value)
+{
+  if(value < -128) return -128;
+  if(value >  127) return  127;
+  return (Bit8s) value;
+}
+
+Bit16s SaturateDwordSToWordS(Bit32s value)
+{
+  if(value < -32768) return -32768;
+  if(value >  32767) return  32767;
+  return (Bit16s) value;
+}
+
+Bit8u SaturateWordSToByteU(Bit16s value)
+{
+  if(value < 0) return 0;
+  if(value > 255) return 255;
+  return (Bit8u) value;
+}
+
+Bit16u SaturateDwordSToWordU(Bit32s value)
+{
+  if(value < 0) return 0;
+  if(value > 65535) return 65535;
+  return (Bit16u) value;
+}
+
+void setFPU(Bit16u tag) {
+	FPU_SET_TOP(0);
+	TOP=FPU_GET_TOP();
+	FPU_SetTag(tag);
+}
\ No newline at end of file
diff -urN dosbox_orig/src/cpu/paging.cpp dosbox/src/cpu/paging.cpp
--- dosbox_orig/src/cpu/paging.cpp	2011-11-29 17:45:45.000000000 +0100
+++ dosbox/src/cpu/paging.cpp	2011-12-20 22:57:32.000000000 +0100
@@ -237,6 +237,7 @@
 	case CPU_ARCHTYPE_486OLDSLOW:
 	case CPU_ARCHTYPE_486NEWSLOW:
 	case CPU_ARCHTYPE_PENTIUMSLOW:
+	case CPU_ARCHTYPE_P55CSLOW:
 		return ((u1)==0) || ((u2)==0);
 	}
 }
@@ -342,6 +343,7 @@
 					case CPU_ARCHTYPE_486OLDSLOW:
 					case CPU_ARCHTYPE_486NEWSLOW:
 					case CPU_ARCHTYPE_PENTIUMSLOW:
+					case CPU_ARCHTYPE_P55CSLOW:
 						priv_check=1;
 						break;
 					}
@@ -360,6 +362,7 @@
 					case CPU_ARCHTYPE_486OLDSLOW:
 					case CPU_ARCHTYPE_486NEWSLOW:
 					case CPU_ARCHTYPE_PENTIUMSLOW:
+					case CPU_ARCHTYPE_P55CSLOW:
 						priv_check=2;
 						break;
 					}
diff -urN dosbox_orig/src/dosbox.cpp dosbox/src/dosbox.cpp
--- dosbox_orig/src/dosbox.cpp	2011-11-01 18:00:19.000000000 +0100
+++ dosbox/src/dosbox.cpp	2011-12-20 22:59:47.000000000 +0100
@@ -411,7 +411,11 @@
 	Pstring->Set_help("CPU Core used in emulation. auto will switch to dynamic if available and\n"
 		"appropriate.");
 
-	const char* cputype_values[] = { "auto", "386", "386_slow", "486_slow", "pentium_slow", "386_prefetch", 0};
+	const char* cputype_values[] = { "auto", "386", "386_slow", "486_slow", "pentium_slow", 
+#if C_MMX
+		"pentium_mmx_slow",
+#endif
+		"386_prefetch", 0};
 	Pstring = secprop->Add_string("cputype",Property::Changeable::Always,"auto");
 	Pstring->Set_values(cputype_values);
 	Pstring->Set_help("CPU Type used in emulation. auto is the fastest choice.");
diff -urN dosbox_orig/src/platform/visualc/config.h dosbox/src/platform/visualc/config.h
--- dosbox_orig/src/platform/visualc/config.h	2010-10-29 22:33:50.000000000 +0200
+++ dosbox/src/platform/visualc/config.h	2011-12-20 20:51:10.000000000 +0100
@@ -37,6 +37,9 @@
 /* Define to 1 to use a x86 assembly fpu core */
 #define C_FPU_X86 1
 
+/* Enable MMX instruction set */
+#define C_MMX 1
+
 /* Define to 1 to use a unaligned memory access */
 #define C_UNALIGNED_MEMORY 1
 
